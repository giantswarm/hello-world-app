# Default values for hello-world.
# This is a YAML-formatted file.
# Declare default variables to be passed into your templates.
#
# To learn more about how to configure your app on your cluster
# and override the default values in here, visit:
#
#   https://docs.giantswarm.io/tutorials/fleet-management/app-platform/app-configuration/#basic-values-merging-example
#

# @schema type:integer;minimum:1
# -- This will set the replicaset count more information can be found here: https://kubernetes.io/docs/concepts/workloads/controllers/replicaset/
replicaCount: 0

# -- This sets the container image more information can be found here: https://kubernetes.io/docs/concepts/containers/images/
image:
  # @schema type:string
  # -- Container image registry
  registry: gsoci.azurecr.io
  # @schema type:string
  # -- Container image repository
  repository: giantswarm/helloworld
  # @schema enum:[IfNotPresent, Always, Never]
  # -- This sets the pull policy for images.
  pullPolicy: IfNotPresent
  # @schema type:string
  # -- Overrides the image tag whose default is the chart appVersion.
  tag: ""

# @schema type:array
# -- This is for the secretes for pulling an image from a private repository more information can be found here: https://kubernetes.io/docs/tasks/configure-pod-container/pull-image-private-registry/
imagePullSecrets: []
# @schema type:string
# -- This is to override the chart name.
nameOverride: ""
# @schema type:string
# -- Override the full name of the chart
fullnameOverride: ""

# -- This section builds out the service account more information can be found here: https://kubernetes.io/docs/concepts/security/service-accounts/
serviceAccount:
  # @schema type:boolean
  # -- Specifies whether a service account should be created
  create: true
  # @schema type:boolean
  # -- Automatically mount a ServiceAccount's API credentials?
  automount: false
  # @schema type:object
  # -- Annotations to add to the service account
  annotations: {}
  # @schema type:string
  # -- The name of the service account to use. If not set and create is true, a name is generated using the fullname template
  name: ""

# @schema type:object
# -- This is for setting Kubernetes Annotations to a Pod. For more information checkout: https://kubernetes.io/docs/concepts/overview/working-with-objects/annotations/
podAnnotations: {}
# @schema type:object
# -- This is for setting Kubernetes Labels to a Pod. For more information checkout: https://kubernetes.io/docs/concepts/overview/working-with-objects/labels/
podLabels: {}

# @schema type:object
# -- Pod security context configuration
podSecurityContext: {}
  # fsGroup: 2000

# @schema type:object
# -- Container security context configuration
securityContext:
  # @schema type:boolean
  # -- Run container as non-root user
  runAsNonRoot: true
  # @schema type:integer
  # -- User ID to run the container
  runAsUser: 1000
  # @schema type:boolean
  # -- Allow privilege escalation
  allowPrivilegeEscalation: false
  # @schema type:object
  # -- Seccomp profile configuration
  seccompProfile:
    # @schema type:string
    # -- Seccomp profile type
    type: RuntimeDefault
  # @schema type:object
  # -- Capabilities configuration
  capabilities:
    # @schema type:array
    # -- Capabilities to drop
    drop:
      - ALL
  # @schema type:boolean
  # -- Mount root filesystem as read-only
  readOnlyRootFilesystem: true

# -- This is for setting up a service more information can be found here: https://kubernetes.io/docs/concepts/services-networking/service/
service:
  # @schema enum:[ClusterIP, NodePort, LoadBalancer, ExternalName]
  # -- This sets the service type more information can be found here: https://kubernetes.io/docs/concepts/services-networking/service/#publishing-services-service-types
  type: ClusterIP
  # @schema type:integer;minimum:1;maximum:65535
  # -- This sets the ports more information can be found here: https://kubernetes.io/docs/concepts/services-networking/service/#field-spec-ports
  port: 80
  # @schema type:object
  # -- Service labels
  labels: {}
  # @schema type:object
  # -- Service annotations
  annotations: {}

# -- This block is for setting up the ingress more information can be found here: https://kubernetes.io/docs/concepts/services-networking/ingress/
ingress:
  # @schema type:boolean
  # -- Enable ingress
  enabled: true
  # @schema type:string
  # -- Ingress class name
  className: nginx
  # @schema type:object
  # -- Ingress annotations
  annotations:
    # kubernetes.io/ingress.class: nginx
    # kubernetes.io/tls-acme: "true"
    cert-manager.io/cluster-issuer: letsencrypt-giantswarm
  # @schema type:array
  # -- Ingress hosts configuration
  hosts:
    - host: hello.cluster.provider.gigantic.io
      paths:
        - path: /
          pathType: Prefix
  # @schema type:array
  # -- TLS configuration for ingress
  tls:
    - secretName: hello-world-tls
      hosts:
        - hello.cluster.provider.gigantic.io

# -- This block is for setting up Gateway API routes. More information can be found here: https://gateway-api.sigs.k8s.io/
route:
  # @schema type:boolean
  # -- Enable Gateway API route
  enabled: false
  # @schema enum:[GRPCRoute, HTTPRoute, TCPRoute, TLSRoute, UDPRoute]
  # -- Set the route kind. Valid options are GRPCRoute, HTTPRoute, TCPRoute, TLSRoute, UDPRoute
  kind: HTTPRoute
  # @schema type:string
  # -- Override the route name (defaults to fullname)
  name: ""

  # @schema type:object
  # -- Route annotations
  annotations: {}
  # @schema type:object
  # -- Route labels
  labels: {}

  # @schema type:array
  # -- Hostnames that the route should match. Supports templating with {{ .Values.xxx }}
  hostnames: []
  # - hello.cluster.provider.gigantic.io

  # @schema type:array
  # -- Parent gateway references
  parentRefs: []
  # - name: giantswarm-default
  #   namespace: envoy-gateway-system

  # @schema type:array
  # -- Request matching rules
  matches:
    - path:
        type: PathPrefix
        value: /

  # @schema type:array
  # -- Filters define the filters that are applied to requests that match this rule
  filters: []
  # - type: RequestHeaderModifier
  #   requestHeaderModifier:
  #     add:
  #       - name: X-Custom-Header
  #         value: custom-value

  # @schema type:array
  # -- Additional custom rules that can be added to the route. Supports templating
  additionalRules: []

  # -- Envoy Gateway SecurityPolicy configuration
  securityPolicy:
    # @schema type:boolean
    # -- Enable security policy
    enabled: false
    # @schema type:object
    # -- Security policy annotations
    annotations: {}
    # @schema type:object
    # -- Security policy labels
    labels: {}
    # basicAuth:
    #   users:
    #     name: <secret_name>
    # cors:
    #   allowOrigins:
    #     - type: Exact
    #       value: "https://example.com"
    #   allowMethods:
    #     - GET
    #     - POST
    #   allowHeaders:
    #     - Content-Type
    # jwt:
    #   providers:
    #     - name: example
    #       issuer: https://example.com
    #       audiences:
    #         - my-audience
    #       remoteJWKS:
    #         uri: https://example.com/.well-known/jwks.json
    # oidc:
    #   provider:
    #     issuer: https://example.com
    #   clientID: my-client-id
    #   clientSecret:
    #     name: oidc-secret
    # extAuth:
    #   grpc:
    #     backendRef:
    #       name: auth-service
    #       port: 9091
    # authorization:
    #   defaultAction: Deny
    #   rules:
    #     - action: Allow
    #       principal:
    #         jwt:
    #           provider: example
    #           scopes:
    #             - read

# @schema type:object
# -- Resource requests and limits for the container
resources:
  # @schema type:object
  # -- Resource requests
  requests:
    # @schema type:string
    # -- CPU request
    cpu: 200m
    # @schema type:string
    # -- Memory request
    memory: 50Mi
  # @schema type:object
  # -- Resource limits
  limits:
    # @schema type:string
    # -- CPU limit
    cpu: 400m
    # @schema type:string
    # -- Memory limit
    memory: 100Mi

# @schema type:object
# -- This is to setup the liveness and readiness probes more information can be found here: https://kubernetes.io/docs/tasks/configure-pod-container/configure-liveness-readiness-startup-probes/
livenessProbe:
  # @schema type:object
  # -- HTTP GET probe configuration
  httpGet:
    # @schema type:string
    # -- Probe path
    path: /
    # @schema type:[string, integer]
    # -- Probe port
    port: http
# @schema type:object
# -- Readiness probe configuration
readinessProbe:
  # @schema type:object
  # -- HTTP GET probe configuration
  httpGet:
    # @schema type:string
    # -- Probe path
    path: /
    # @schema type:[string, integer]
    # -- Probe port
    port: http

# -- This section is for setting up autoscaling more information can be found here: https://kubernetes.io/docs/concepts/workloads/autoscaling/
autoscaling:
  # @schema type:boolean
  # -- Enable autoscaling
  enabled: true
  # @schema type:integer;minimum:1
  # -- Minimum number of replicas
  minReplicas: 1
  # @schema type:integer;minimum:1
  # -- Maximum number of replicas
  maxReplicas: 100
  # @schema type:integer;minimum:1;maximum:100
  # -- Target CPU utilization percentage
  targetCPUUtilizationPercentage: 80
  # @schema type:integer;minimum:1;maximum:100
  # -- Target memory utilization percentage
  targetMemoryUtilizationPercentage: 80

# @schema type:object
# -- Deployment strategy configuration
strategy:
  # @schema enum:[RollingUpdate, Recreate]
  # -- Deployment strategy type
  type: RollingUpdate
  # @schema type:object
  # -- Rolling update configuration
  rollingUpdate:
    # @schema type:[integer, string]
    # -- Maximum number of unavailable pods during update
    maxUnavailable: 1
    # @schema type:[integer, string]
    # -- Maximum number of pods that can be created above the desired replica count
    maxSurge: 1

# @schema type:array
# -- Additional volumes on the output Deployment definition.
volumes: []
# - name: foo
#   secret:
#     secretName: mysecret
#     optional: false

# @schema type:array
# -- Additional volumeMounts on the output Deployment definition.
volumeMounts: []
# - name: foo
#   mountPath: "/etc/foo"
#   readOnly: true

# @schema type:object
# -- Node selector for pod scheduling
nodeSelector: {}

# @schema type:array
# -- Tolerations for pod scheduling
tolerations: []

# @schema type:object
# -- Affinity rules for pod scheduling
affinity: {}

# @schema type:array
# -- Topology spread constraints for pod distribution
topologySpreadConstraints:
  - labelSelector:
      matchLabels:
        app.kubernetes.io/name: '{{ include "hello-world.name" . }}'
        app.kubernetes.io/instance: "{{ .Release.Name }}"
    topologyKey: topology.kubernetes.io/zone
    maxSkew: 1
    whenUnsatisfiable: ScheduleAnyway
  - labelSelector:
      matchLabels:
        app.kubernetes.io/name: '{{ include "hello-world.name" . }}'
        app.kubernetes.io/instance: "{{ .Release.Name }}"
    topologyKey: kubernetes.io/hostname
    maxSkew: 1
    whenUnsatisfiable: ScheduleAnyway

# -- Pod disruption budget configuration
podDisruptionBudget:
  # @schema type:boolean
  # -- Enable pod disruption budget
  enabled: true
  # @schema type:[integer, string]
  # -- Maximum number of unavailable pods. Define either 'minAvailable' or 'maxUnavailable', never both.
  # minAvailable: 1
  maxUnavailable: 1

# -- ServiceMonitor configuration for Prometheus
serviceMonitor:
  # @schema type:boolean
  # -- Enable ServiceMonitor
  enabled: false
